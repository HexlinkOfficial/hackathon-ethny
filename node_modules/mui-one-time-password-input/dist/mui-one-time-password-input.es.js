import { jsx as E } from "react/jsx-runtime";
import p from "react";
import { styled as Z } from "@mui/material/styles";
import v from "@mui/material/TextField";
import ee from "@mui/material/Box";
const te = Z(v)`
  input {
    text-align: center;
  }
`, ne = {
  TextFieldStyled: te
}, re = (r) => /* @__PURE__ */ E(ne.TextFieldStyled, { ...r }), y = {
  left: "ArrowLeft",
  right: "ArrowRight",
  backspace: "Backspace",
  home: "Home",
  end: "End"
};
function ae(r, o) {
  return r <= 0 ? [] : Array.from({ length: r }, o);
}
function oe(r, o, u) {
  return r.map((c, h) => o === h ? u : c);
}
function P(r) {
  return r.join("");
}
function S(r, o) {
  return [...r, o];
}
function se(r, o, u) {
  return r.reduce(
    (c, h, m) => {
      const { characters: C, restArrayMerged: d } = c;
      if (m < u)
        return {
          restArrayMerged: d,
          characters: S(C, h)
        };
      const [x, ...B] = d;
      return {
        restArrayMerged: B,
        characters: S(C, x || "")
      };
    },
    {
      restArrayMerged: o,
      characters: []
    }
  ).characters;
}
function le(r) {
  return r.split("");
}
function M(r) {
  const o = p.useRef(() => {
    throw new Error("Cannot call an event handler while rendering.");
  });
  return p.useInsertionEffect(() => {
    o.current = r;
  }), p.useCallback((...u) => o.current?.(...u), []);
}
const ce = () => !0, he = p.forwardRef(
  (r, o) => {
    const {
      value: u = "",
      length: c = 4,
      autoFocus: h = !1,
      onChange: m,
      TextFieldsProps: C,
      onComplete: d,
      validateChar: x = ce,
      className: B,
      onBlur: N,
      ...b
    } = r, K = p.useRef(u), V = M(d), g = M((e) => ({
      isCompleted: e.length >= c,
      finalValue: e.slice(0, c)
    })), {
      onPaste: j,
      onFocus: $,
      onKeyDown: Y,
      className: _,
      placeholder: D,
      onBlur: H,
      ...L
    } = C || {};
    p.useEffect(() => {
      const { isCompleted: e, finalValue: t } = g(
        K.current
      );
      e && V(t);
    }, [c, V, g]);
    const i = ae(
      c,
      (e, t) => ({
        character: u[t] || "",
        inputRef: p.createRef()
      })
    ), k = (e) => i.findIndex(({ inputRef: t }) => t.current === e), A = () => i.map(({ character: e }) => e), O = (e, t) => {
      const n = oe(
        A(),
        e,
        t
      );
      return P(n);
    }, W = (e) => {
      i[e]?.inputRef.current?.focus();
    }, l = (e) => {
      i[e]?.inputRef.current?.select();
    }, T = (e) => {
      e + 1 !== c && (i[e + 1].character ? l(e + 1) : W(e + 1));
    }, R = (e, t) => typeof x != "function" ? !0 : x(e, t), q = (e) => {
      const t = e.target.value[0] || "";
      let n = t;
      const s = k(e.target);
      n && !R(n, s) && (n = "");
      const a = O(s, n);
      m?.(a);
      const { isCompleted: I, finalValue: f } = g(a);
      I && d?.(f), n !== "" ? a.length - 1 < s ? l(a.length) : T(s) : t === "" && a.length <= s && l(s - 1);
    }, z = (e) => {
      e.preventDefault(), e.target.select(), $?.(e);
    }, G = (e) => {
      const t = e.target, n = t.selectionStart, s = t.selectionEnd, a = k(t), I = n === 0 && s === 0;
      if (t.value === e.key)
        e.preventDefault(), T(a);
      else if (y.backspace === e.key) {
        if (!t.value)
          e.preventDefault(), l(a - 1);
        else if (I) {
          e.preventDefault();
          const f = O(a, "");
          m?.(f), f.length <= a && l(a - 1);
        }
      } else
        y.left === e.key ? (e.preventDefault(), l(a - 1)) : y.right === e.key ? (e.preventDefault(), l(a + 1)) : y.home === e.key ? (e.preventDefault(), l(0)) : y.end === e.key && (e.preventDefault(), l(i.length - 1));
      Y?.(e);
    }, J = (e) => {
      e.preventDefault();
      const t = e.clipboardData.getData("text/plain"), n = e.target, s = i.findIndex(
        ({ character: F, inputRef: w }) => F === "" || w.current === n
      ), a = A(), I = se(
        a,
        le(t),
        s
      ).map((F, w) => R(F, w) ? F : ""), f = P(I);
      m?.(f);
      const { isCompleted: U, finalValue: X } = g(f);
      U ? (d?.(X), l(c - 1)) : l(f.length), j?.(e);
    }, Q = (e) => {
      if (H?.(e), !i.some(({ inputRef: n }) => n.current === e.relatedTarget)) {
        const { isCompleted: n, finalValue: s } = g(u);
        N?.(s, n);
      }
    };
    return /* @__PURE__ */ E(
      ee,
      {
        display: "flex",
        gap: "20px",
        alignItems: "center",
        ref: o,
        className: `MuiOtpInput-Box ${B || ""}`,
        ...b,
        children: i.map(({ character: e, inputRef: t }, n) => /* @__PURE__ */ E(
          re,
          {
            autoFocus: h ? n === 0 : !1,
            autoComplete: "one-time-code",
            value: e,
            inputRef: t,
            className: `MuiOtpInput-TextField MuiOtpInput-TextField-${n + 1} ${_ || ""}`,
            onPaste: J,
            onFocus: z,
            onChange: q,
            onKeyDown: G,
            onBlur: Q,
            placeholder: typeof D == "function" ? D(n) : D,
            ...L
          },
          n
        ))
      }
    );
  }
);
export {
  he as MuiOtpInput
};
