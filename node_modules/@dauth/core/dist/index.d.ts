interface IOtpConfirmReturn {
    auth: {
        acc_and_type_hash: string;
        request_id: string;
    };
    signature: string;
    ustore?: {
        user_key: "";
        user_key_sealed: "";
        user_key_signed: "";
    };
}
type TAccount_type = 'mailto' | 'tel';
type TID_type = 'google' | 'github' | 'apple' | 'twitter' | 'mailto' | 'tel';
type TSign_mode = 'jwt' | 'proof' | 'jwtfb' | 'both';
declare enum ESignMode {
    JWT = "jwt",
    PROOF = "proof",
    JWT_FIREBASE = "jwtfb",
    BOTH = "both"
}
interface IDauthConfig {
    baseURL: string;
    clientID: string;
}

declare class DAuthHttpService {
    private instance;
    private session_id;
    private shareKey;
    constructor(dauthConfig: IDauthConfig);
    private createChanel;
    exchangeKey: (key: string) => Promise<{
        key: string;
        session_id: string;
    }>;
    exchangeKeyAndEncrypt(rawText: string, fresh?: boolean): Promise<{
        session_id: string;
        cipher_str: string | undefined;
    }>;
    exchangeKeyAndDecrypt(cipherText: string): Promise<{
        session_id: string;
        originalText: string | undefined;
    }>;
    authOauth({ token, request_id, id_type, mode, withPlainAccount }: {
        token: string;
        request_id: string;
        id_type: TID_type;
        mode: ESignMode;
        withPlainAccount?: boolean;
    }): Promise<any>;
    sendOtp({ account, request_id, id_type }: {
        account: string;
        id_type: TAccount_type;
        request_id?: string;
    }): Promise<boolean>;
    authOtpConfirm({ code, request_id, mode, id_type, withPlainAccount }: {
        code: string;
        request_id: string;
        mode: ESignMode;
        id_type: TID_type;
        withPlainAccount?: boolean;
    }): Promise<any>;
    authOtpConfirmAndGenerateKey({ code, request_id, mode, id_type, withPlainAccount }: {
        code: string;
        request_id: string;
        mode: ESignMode;
        id_type: TID_type;
        withPlainAccount?: boolean;
    }): Promise<any>;
    authOtpConfirmAndRecoverKey({ code, request_id, mode, id_type, user_key, user_key_signature, withPlainAccount }: {
        code: string;
        request_id: string;
        mode: ESignMode;
        id_type: TID_type;
        user_key: string;
        user_key_signature: string;
        withPlainAccount?: boolean;
    }): Promise<any>;
}

declare const isEmail: (email: string) => boolean;
declare const sleep: (ms?: number) => Promise<void>;
declare const verifyProof: (proof: IOtpConfirmReturn, dauthSignerAddress?: string) => boolean;

declare class DAuth {
    baseURL: string;
    service: DAuthHttpService;
    constructor(dauthConfig: IDauthConfig);
}

export { ESignMode, IDauthConfig, IOtpConfirmReturn, TAccount_type, TID_type, TSign_mode, DAuth as default, isEmail, sleep, verifyProof };
